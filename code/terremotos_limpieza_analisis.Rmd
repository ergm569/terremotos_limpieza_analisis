---
title: 'Tipología y ciclo de vida de los datos: PRA2'
author: "Autores: Erick Franz García Miranda y Rafael Eduardo Garcia Agramonte"
date: "Abril 2021"
output:
  html_document:
    highlight: default
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_depth: 2
    includes:
      in_header:
  pdf_document:
    highlight: zenburn
    toc: yes
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval=T, echo=T)
```


```{r echo=FALSE, message=FALSE, warning=FALSE}
# Instala paquetes que faltan por instalarse

list.of.packages <- c("lubridate", "stringr", "tidygeocoder", "dplyr")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages, repos='https://cran.rediris.es/')
```


******
# Descripción del dataset
******

El dataset corresponde al generado en la PRA1 utilizando tecnicas de webscraping con Python al sitio web: https://www.volcanodiscovery.com/es/earthquakes/ que muestra información de eventos sismicos al rededor del mundo.

El dataset contiene información de terremotos de 15 paises de centro y sur america como son: Argentina, Bolivia, Brasil, Chile, Colombia, Costa Rica, Ecuador, Guatemala, México, Panamá, Paraguay, Perú, Puerto Rico, República Dominicana, Venezuela); en el perido de 01 de enero del 2010 hasta el 05 de abril del 2021. El dataset tiene formato .csv y tiene **12507 registros.**

Cada registro representa un evento sismico y contiene los siguientes campos:

* **Fecha y Hora:** Fecha en formato día-mes-año y hora específicos en que ocurrió el sismo.
* **Magnitud:** Indica la de magnitud del sismo en escala sismológica de richter.
* **Profundidad:** Distancia de donde se origina el fenómeno con respecto al centro de la tierra.
* **Ubicación:** Lugar en donde se produjo el sismo.
* **Año:** Año en que ocurrió el sismo.
* **País:** Nombre de la nación afectada por el sismo.

******
# Integración y selección
******

Primero, importaremos el dataset.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Importamos el data set
data_terremotos<-read.csv("../data/terremotos_centro_sur_america.csv", encoding="UTF-8", header=T,sep=",")
paises_de_america<-read.csv("../data/Paises.csv", encoding="ANSI", header=T,sep=",")
head(data_terremotos)
# Cantidad de registros
dim(data_terremotos)[1]
```

***Fecha y hora:***

Convertiremos la fecha y hora del tipo de cadena de texto al de fecha y hora:

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Cargamos la librería Lubridate 
library(lubridate)

# Convertimos a tipo fecha y hora
data_terremotos$Fecha.y.Hora <- dmy_hms(substr(data_terremotos$Fecha.y.Hora, start = 1 , stop = 20) )
head(data_terremotos$Fecha.y.Hora)
```

Creamos algunas columnas adicionales que serán útiles al momento de realizar los analisis.


```{r echo=TRUE, message=FALSE, warning=FALSE}
# Número de mes
data_terremotos$Mes <- month(data_terremotos$Fecha.y.Hora)
# Hora
data_terremotos$Hora <- hour(data_terremotos$Fecha.y.Hora)
# Día de la semana
data_terremotos$Dia.Semana <- wday(data_terremotos$Fecha.y.Hora, label = TRUE, abbr = FALSE)
```

***Magnitud y Profundidad***

Tranformaremos los campos de Magnitud y Profundidad de tipo cadena de texto a valores numéricos:


```{r echo=TRUE, message=FALSE, warning=FALSE}
# Convertimos a tipo numérico la Magnitud
data_terremotos$Magnitud <- as.numeric(data_terremotos$Magnitud)

# Quitamos los caracteres y convertimos a tipo numérico la Profundidad
data_terremotos$Profundidad <- gsub('Â', '', data_terremotos$Profundidad)
data_terremotos$Profundidad <- gsub('km', '', data_terremotos$Profundidad)
data_terremotos$Profundidad <- gsub('.{1}$', '', data_terremotos$Profundidad)
data_terremotos$Profundidad <- as.numeric(data_terremotos$Profundidad)
```

```{r echo=TRUE, message=FALSE, warning=FALSE}
library(stringr)


word <- function(string, start = 1L, end = start, sep = fixed(" ")) {
  args <- vctrs::vec_recycle_common(string = string, start = start, end = end)
  string <- args$string
  start <- args$start
  end <- args$end

  breaks <- str_locate_all(string, sep)
  words <- lapply(breaks, invert_match)

  # Convert negative values into actual positions
  len <- vapply(words, nrow, integer(1))

  neg_start <- !is.na(start) & start < 0L
  start[neg_start] <- start[neg_start] + len[neg_start] + 1L

  neg_end <- !is.na(end) & end < 0L
  end[neg_end] <- end[neg_end] + len[neg_end] + 1L

  # Replace indexes past end with NA
  start[start > len] <- NA
  end[end > len] <- NA

  # To return all words when trying to extract more words than available
  start[start < 1L] <- 1

  # Extract locations
  starts <- mapply(function(word, loc) word[loc, "start"], words, start)
  ends <-   mapply(function(word, loc) word[loc, "end"], words, end)

  str_sub(string, starts, ends)
}


# Calcular punto cardinal para usar en futuro cálculo de coordenada de ubicación de sismo.

#data_terremotos$puntoCardinal <- word(word(data_terremotos$Ubicacion, start = 2, sep = fixed('km al ')), 1)

# Función para punto cardinal

 existe_punto_cardinal <- function(x) {
  library(dplyr)
  case_when(
    tolower(word(word(x, start = 2, sep = fixed("km al ")), 1)) == "norte" ~ "norte",
    tolower(word(word(x, start = 2, sep = fixed("km al ")), 1)) == "noreste" ~  "noreste",
    tolower(word(word(x, start = 2, sep = fixed("km al ")), 1)) == "este" ~  "este",
    tolower(word(word(x, start = 2, sep = fixed("km al ")), 1)) == "sureste" ~  "sureste",
    tolower(word(word(x, start = 2, sep = fixed("km al ")), 1)) == "sur" ~  "sur",
    tolower(word(word(x, start = 2, sep = fixed("km al ")), 1)) == "suroeste" ~  "suroeste",
    tolower(word(word(x, start = 2, sep = fixed("km al ")), 1)) == "oeste" ~  "oeste",
    tolower(word(word(x, start = 2, sep = fixed("km al ")), 1)) == "noroeste" ~  "noroeste",
#    TRUE ~ x
    TRUE ~ data_terremotos$Ubicacion
  )
 }
 
 zona_de_sismo <- function(x) {
  case_when(
    x == "norte" ~ word(data_terremotos$Ubicacion, start = 2, sep = fixed(paste(data_terremotos$puntoCardinal,' de ',sep=""))),
    x == "noreste" ~ word(data_terremotos$Ubicacion, start = 2, sep = fixed(paste(data_terremotos$puntoCardinal,' de ',sep=""))),
    x == "este" ~  word(data_terremotos$Ubicacion, start = 2, sep = fixed(paste(data_terremotos$puntoCardinal,' de ',sep=""))),
    x == "sureste" ~  word(data_terremotos$Ubicacion, start = 2, sep = fixed(paste(data_terremotos$puntoCardinal,' de ',sep=""))),
    x == "sur" ~  word(data_terremotos$Ubicacion, start = 2, sep = fixed(paste(data_terremotos$puntoCardinal,' de ',sep=""))),
    x == "suroeste" ~  word(data_terremotos$Ubicacion, start = 2, sep = fixed(paste(data_terremotos$puntoCardinal,' de ',sep=""))),
    x == "oeste" ~  word(data_terremotos$Ubicacion, start = 2, sep = fixed(paste(data_terremotos$puntoCardinal,' de ',sep=""))),
    x == "noroeste" ~  word(data_terremotos$Ubicacion, start = 2, sep = fixed(paste(data_terremotos$puntoCardinal,' de ',sep=""))),
    TRUE ~ data_terremotos$Ubicacion
  )
 }
 
 zona_de_sismo2 <- function(x) {
  y <- word(data_terremotos$Ubicacion, start = 2, sep = fixed(paste(data_terremotos$puntoCardinal,' de ',sep=""))) 
  case_when(
    x == "norte" ~ y,
    x == "noreste" ~ y,
    x == "este" ~  y,
    x == "sureste" ~  y,
    x == "sur" ~  y,
    x == "suroeste" ~  y,
    x == "oeste" ~  y,
    x == "noroeste" ~  y,
    TRUE ~ data_terremotos$Ubicacion
  )
 }

  zona_de_sismo3 <- function(x) {
  y <- word(data_terremotos$Ubicacion, start = 2, sep = fixed(paste(data_terremotos$puntoCardinal,' de ',sep=""))) 
  case_when(
    x == "norte" ~ y,
    x == "noreste" ~ y,
    x == "este" ~  y,
    x == "sureste" ~  y,
    x == "sur" ~  y,
    x == "suroeste" ~  y,
    x == "oeste" ~  y,
    x == "noroeste" ~  y,
    TRUE ~ data_terremotos$Ubicacion
  )
  return(y)
 }
 
data_terremotos$puntoCardinal <- str_trim(existe_punto_cardinal(data_terremotos$Ubicacion))

validar_pais2 <- function(z) {
  r <- data.frame(z)
  s <- data.frame(paises_de_america)
  h <- ""
  delimitador <- ".*"
  
  for (a in 1:nrow(z)) {
    for (g in 1:nrow(s)) {
      if (grepl(paises_de_america$Paises[g], z$Paises[a])) {
        r$Paises[a] <-
          paste((gsub(
            pattern = (paste((
              str_trim(s$Paises[g])
            ), delimitador, sep = "")), "", x = z$Paises[a]
          )), (str_trim(s$Paises[g])), sep = "")
        break
      } else {
        r$Paises[a] <- z$Paises[a]
      }
    }
  }
  return(r)
}

validar_pais3 <- function(z) {
  r <- data.frame(z)
  s <- data.frame(paises_de_america)
  h <- ""
  delimitador <- ".*"
  
  for (a in 1:nrow(z)) {
    for (g in 1:nrow(s)) {
      if (grepl(paises_de_america$Paises[g], z$Zona.de.referencia[a])) {
        r$Zona.de.referencia[a] <- str_trim(
          paste((gsub(
            pattern = (paste((
              str_trim(s$Paises[g])
            ), delimitador, sep = "")), "", x = z$Zona.de.referencia[a]
          )), (str_trim(s$Paises[g])), sep = ""))
        break
      } else {
        r$Zona.de.referencia[a] <- str_trim(z$Zona.de.referencia[a])
      }
    }
  }
  return(r)
}

data_terremotos$Zona.de.referencia <- zona_de_sismo2(data_terremotos$puntoCardinal)
#data_terremotos$Zona.de.referencia2 <- validar_pais2(data_terremotos$Zona.de.referencia)
variable_final <- validar_pais3(data_terremotos)

#data_terremotos$Zona.de.referencia3 <- nrow(data_terremotos$Zona.de.referencia)
# Calcular zona de referencia.

# data_terremotos$Zona.de.referencia <- word(data_terremotos$Ubicacion, start = 2, sep = fixed(paste(data_terremotos$puntoCardinal,' de ',sep="")))
# 
print(data_terremotos$puntoCardinal)
print(data_terremotos$Zona.de.referencia)
print(variable_final$Zona.de.referencia)
print(variable_final$Latitud)
print(variable_final$Longitud)

```

******
# Limpieza
******

##  Elementos vacios

Vamos a revisar los valores vacios del dataset:

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Estadísticas de valores vacíos
colSums(is.na(data_terremotos))
colSums(data_terremotos[c("Magnitud","Profundidad","Ubicacion")]=="")
```

Podemos observar que no existen valores nulos, por lo que no será necesario realizar un tratamiento.

##  Valores extremos

Primero, realizaremos un analisis de los valores extremos para la Profundidad y la Magnitud de manera individual a través de boxplots.

Analizaremos la Profundidad.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Calcular el boxplot de la Profundidad
Profundidad.bp <- boxplot(data_terremotos$Profundidad)
# Calculamos el rango de los outliers
range(Profundidad.bp$out)
# Calcular la cantidad de los outliers
length(Profundidad.bp$out)
```

Podemos observar que existen 159 valores outliers de la variable Profundidad que **tienen valores entre 288 a 750 km.**

Ahora, analizaremos la Magnitud.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Calcular el boxplot de la Magnitud
Magnitud.bp <- boxplot(data_terremotos$Magnitud)
# Calculamos el rango de los outliers
range(Magnitud.bp$out)
# Calcular la cantidad de los outliers
length(Magnitud.bp$out)
```

Observamos que o existen outliers de la variable Magnitud.

También, analizaremos las variables Profundidad y Magnitud utilizando la **distancia de Mahalanobis** para encontrar 100 outliers.

```{r echo=TRUE, message=FALSE, warning=FALSE}
#ap <- data.frame(Altura.cm=c(164, 167, 168, 169, 169, 170, 170, 170, 171,172, 172, 173, 173, 175, 176, 178), Peso.kg=c( 54, 57, 58, 60, 61, 60,61, 62, 62, 64, 62, 62, 64, 56, 66, 70))


#Criterio +/-2SD
ap <- data_terremotos[,c("Profundidad","Magnitud")]
Profundidad.outlier <- abs(scale(data_terremotos$Profundidad)) > 2
Magnitud.outlier <- abs(scale(data_terremotos$Magnitud)) > 2
pch <- (Profundidad.outlier | Magnitud.outlier) * 12
pch <- pch + 4
col <- (Profundidad.outlier | Magnitud.outlier) * 12
col <- pch + 4
  
par(mfrow=c(1,2))
plot(ap, pch=pch,col=col,main="Criterio +-2 Desv.Stand.")

#Criterio distancia Mahalanobis (los dos outliers más extremos)
n.outliers <- 100
m.dist.order <- order(mahalanobis(ap, colMeans(ap), cov(ap)), decreasing=TRUE)
is.outlier <- rep(FALSE, nrow(ap))
is.outlier[m.dist.order[1:n.outliers]] <- TRUE
pch <- is.outlier * 12
pch <- pch + 4
col <- is.outlier * 12
col <- pch + 4
plot(ap, pch=pch,col=col,main="Criterio distancia mahalanobis")
```

Podemos observar que los outliers, según el criterio de mahalanobis, son puntos con altos valores de Profundidad; al igual que con el criterio de -+2 desviaciones estandar. Esto se debe a la manera en que están distribuidos los datos, donde se observa que la Profundidad es la variable con mayor dispersión. 

Hallaremos el rango de los 100 puntos extremos calculados:

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Rango de los outliers
range(ap[is.outlier,]$Profundidad)
```

Finalmente, concluimos que existen 159 outliers con **Profundidades mayores a 288 km (criterio +-2Desv.).** De los cuales los 100 outliers más extremos tienen **Profundidades mayores a 523 km (Criterio mahalanobis).**

Al ser datos reales de sismos, no haremos ningún tratamiento adicional a estos valores.


******
# Analisis de datos
******


##  Planificación

##  Normalidad y Homogeneidad

##  Pruebas estadísticas


******
# Gráficos y tablas de resultados
******


******
# Resolución del problema
******


******
# Código
******



```{r echo=TRUE, message=FALSE, warning=FALSE}

```